---
alwaysApply: false
---
## TESTING

### Guidelines for UNIT

#### VITEST

- Leverage the `vi` object for test doubles - Use `vi.fn()` for function mocks, `vi.spyOn()` to monitor existing functions, and `vi.stubGlobal()` for global mocks. Prefer spies over mocks when you only need to verify interactions without changing behavior.
- Master `vi.mock()` factory patterns - Place mock factory functions at the top level of your test file, return typed mock implementations, and use `mockImplementation()` or `mockReturnValue()` for dynamic control during tests. Remember the factory runs before imports are processed.
- Create setup files for reusable configuration - Define global mocks, custom matchers, and environment setup in dedicated files referenced in your `vitest.config.ts`. This keeps your test files clean while ensuring consistent test environments.
- Use inline snapshots for readable assertions - Replace complex equality checks with `expect(value).toMatchInlineSnapshot()` to capture expected output directly in your test file, making changes more visible in code reviews.
- Monitor coverage with purpose and only when asked - Configure coverage thresholds in `vitest.config.ts` to ensure critical code paths are tested, but focus on meaningful tests rather than arbitrary coverage percentages.
- Make watch mode part of your workflow - Run `vitest --watch` during development for instant feedback as you modify code, filtering tests with `-t` to focus on specific areas under development.
- Explore UI mode for complex test suites - Use `vitest --ui` to visually navigate large test suites, inspect test results, and debug failures more efficiently during development.
- Handle optional dependencies with smart mocking - Use conditional mocking to test code with optional dependencies by implementing `vi.mock()` with the factory pattern for modules that might not be available in all environments.
- Configure jsdom for DOM testing - Set `environment: 'jsdom'` in your configuration for frontend component tests and combine with testing-library utilities for realistic user interaction simulation.
- Handle React act warnings properly - When testing hooks or components that trigger async operations on mount, make the test async, check initial state synchronously, then use `waitFor()` at the end to wait for async operations to complete. This pattern prevents act warnings: `it("should return initial state correctly", async () => { const { result } = renderHook(() => useHook()); expect(result.current.isLoading).toBe(true); await waitFor(() => { expect(result.current.isLoading).toBe(false); }); });`
- Structure tests for maintainability - Group related tests with descriptive `describe` blocks, use explicit assertion messages, and follow the Arrange-Act-Assert pattern to make tests self-documenting.
- Leverage TypeScript type checking in tests - Enable strict typing in your tests to catch type errors early, use `expectTypeOf()` for type-level assertions, and ensure mocks preserve the original type signatures.
- Handle mock chaining for query builders - When mocking chained APIs (like Supabase query builders), ensure each method in the chain returns `this` for chaining using `mockReturnThis()`. The final method in the chain should return a promise: `builder.select.mockReturnThis(); builder.eq.mockReturnThis(); builder.order.mockResolvedValue({ data: [], error: null });`. Always set up the entire chain before calling the mocked function.
- Avoid duplicate assertions consuming mocks - When using `mockReturnValueOnce()` or similar one-time mocks, each call consumes the mock. If you need multiple assertions, either set up fresh mocks for each call or combine assertions into a single `expect()` statement. Example: Instead of calling `await expect(fn()).rejects.toThrow(Error); await expect(fn()).rejects.toThrow("message");`, create separate mock setups for each assertion or verify both conditions in one call.
- Type spies for Promise-returning functions correctly - When spying on functions that return `Promise<T>`, TypeScript may have trouble inferring the correct type for `mockResolvedValue()`. Use an intersection type to extend the spy: `let spy: ReturnType<typeof vi.spyOn> & { mockResolvedValue: (value: T) => void };` and cast during creation: `spy = vi.spyOn(module, "function" as any) as ReturnType<typeof vi.spyOn> & { mockResolvedValue: (value: T) => void };`.
- Ensure mock data includes all required fields - When creating mock objects, verify they include all required fields from the type definition. Use `Partial<>` for optional fields but include all required ones. Check database schema types to ensure fields like `updated_at`, `created_at`, etc. are included in mock data when they're required by the type.

